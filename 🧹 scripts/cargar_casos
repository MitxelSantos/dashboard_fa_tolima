#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Script: Procesar Casos Fiebre Amarilla ‚Üí PostgreSQL
Procesa archivo Excel de casos positivos para sistema de vigilancia
"""

import pandas as pd
import numpy as np
from datetime import datetime, date
from sqlalchemy import create_engine, text
import warnings
import os
warnings.filterwarnings('ignore')

# Configuraci√≥n BD
DATABASE_URL = "postgresql://tolima_admin:tolima2025!@localhost:5432/epidemiologia_tolima"

def procesar_casos_fiebre_amarilla(archivo_excel, hoja=None):
    """
    Procesa casos de fiebre amarilla desde Excel a PostgreSQL
    """
    print("ü¶† PROCESANDO CASOS FIEBRE AMARILLA")
    print("=" * 50)
    
    inicio = datetime.now()
    
    try:
        # 1. CARGAR ARCHIVO EXCEL
        print(f"üìÇ Cargando: {archivo_excel}")
        
        # Detectar hoja autom√°ticamente si no se especifica
        if hoja is None:
            excel_file = pd.ExcelFile(archivo_excel)
            print(f"üìã Hojas disponibles: {excel_file.sheet_names}")
            # Usar la primera hoja o buscar por patr√≥n
            hoja = excel_file.sheet_names[0]
            for sheet in excel_file.sheet_names:
                if any(keyword in sheet.lower() for keyword in ['positivo', 'caso', 'bd']):
                    hoja = sheet
                    break
            print(f"üìÑ Usando hoja: {hoja}")
        
        df = pd.read_excel(archivo_excel, sheet_name=hoja)
        print(f"üìä Registros iniciales: {len(df):,}")
        print(f"üìã Columnas: {len(df.columns)}")
        
        # 2. MAPEO DE COLUMNAS
        print("üîÑ Mapeando columnas...")
        
        # Mapeo de nombres de columnas comunes
        mapeo_columnas = {
            'fec_not': 'fecha_notificacion', 
            'semana': 'semana_epidemiologica',
            'cod_pre': 'codigo_prestador',
            'pri_nom_': 'primer_nombre',
            'seg_nom_': 'segundo_nombre', 
            'pri_ape_': 'primer_apellido',
            'seg_ape_': 'segundo_apellido',
            'tip_ide_': 'tipo_documento',
            'num_ide_': 'numero_documento',
            'edad_': 'edad',
            "sexo_": 'sexo',
            "area_": 'area_residencia',
            "vereda_": "vereda_infeccion",
            "ocupacion_": "ocupacion",
            "tip_ss_": "tipo_seguridad_social",
            "cod_ase_": "codigo_aseguradora",
            "per_etn_": "pertenencia_etnica",
            "estrato_": "estrato",
            "gp_discapacidad": "grupo_discapacidad",
            "gp_desplazado": "grupo_desplazado",
            "gp_migrante": "grupo_migrante",
            "gp_carcela": "grupo_carcela",
            "gp_gestante": "grupo_gestante",
            "sem_ges_": "semana_gestacion",
            "gp_indigena": "grupo_indigena",
            "gp_pobicbf": "grupo_poblacion_icbf",
            "gp_mad_com": "grupo_madre_comunitaria",
            "gp_desmovim": "grupo_desmovilizado",
            "gp_psiquiatr": "grupo_psiquiatrico",
            "gp_vic_viol": "grupo_victima_violencia",
            "gp_otros": "grupo_otros",
            "fuente_": "fuente_informacion",
            "fec_con_": "fecha_consulta",
            "ini_sin_": "inicio_sintomas",
            "tip_cas_": "tipo_caso",
            "pac_hos_": "paciente_hospitalizado",
            "fec_hos_": "fecha_hospitalizacion",
            "con_fin_": "condicion_final",
            "fec_def_": "fecha_defuncion",
            "telefono_": "telefono",
            "fecha_nto_": "fecha_nacimiento",
            "cer_def_": "certificado_defuncion",
            "carne_vacu": "carnet_vacunacion",
            "fec_fa1_": "fecha_vacuna",
            "fiebre": "fiebre",
            "malgias": "mialgias",
            "artralgias_": "artralgias",
            "cefalea": "cefalea",
            "vomito": "vomitos",
            "ictericia": "ictericia",
            "sfaget": "sangrado",
            "oliguria": "oliguria",
            "shock": "shock",
            "bradicardi": "bradicardia",
            "falla_renal": "falla_renal",
            "falla_hepa": "falla_hepatica",
            "hepatomega": "hepatomegalia",
            "hemoptisis": "hemoptisis",
            "hipiremia": "hiperemia",
            "hematemesi": "hematemesis",
            "petequias": "petequias",
            "metrorragi": "metrorragia",
            "melenas": "melenas",
            "equimosis": "equimosis",
            "epistaxis": "epistaxis",
            "hematuria": "hematuria",
            "cas_fam": "caso_familiar",
            "codmuninfec": "codigo_davipola_municipio_infeccion",
            "nom_upgd": "nombre_upg_departamento",
            "npais_procen": "nombre_pais_procedencia",
            "ndep_proce": "nombre_departamento_procedencia",
            "nmun_proce": "nombre_municipio_procedencia",
            "npais_resi": "nombre_pais_residencia",
            "ndep_resi": "nombre_departamento_residencia",
            "nmun_resi": "nombre_municipio_residencia",
            "ndep_notif": "nombre_departamento_notificacion",
            "nmun_notif": "nombre_municipio_notificacion",
            
            # Agregar m√°s mapeos seg√∫n estructura del archivo
        }
        
        # Aplicar mapeo
        for col_original, col_nueva in mapeo_columnas.items():
            if col_original in df.columns:
                df = df.rename(columns={col_original: col_nueva})
                print(f"   ‚úÖ {col_original} ‚Üí {col_nueva}")
        
        # 3. LIMPIEZA Y PROCESAMIENTO
        print("üßπ Limpiando datos...")
        
        # Limpiar fechas
        def limpiar_fecha(fecha_str):
            if pd.isna(fecha_str):
                return None
            try:
                # Manejar diferentes formatos de fecha
                fecha_str = str(fecha_str).strip()
                if " " in fecha_str:
                    fecha_str = fecha_str.split(" ")[0]
                
                # Intentar formatos comunes
                for formato in ["%d/%m/%Y", "%Y-%m-%d", "%d-%m-%Y", "%m/%d/%Y"]:
                    try:
                        return datetime.strptime(fecha_str, formato).date()
                    except:
                        continue
                return None
            except:
                return None
        
        if 'fecha_notificacion' in df.columns:
            df['fecha_notificacion'] = df['fecha_notificacion'].apply(limpiar_fecha)
        
        # Limpiar nombres y apellidos
        def limpiar_nombre(nombre):
            if pd.isna(nombre):
                return None
            return str(nombre).strip().title()
        
        campos_nombres = ['primer_nombre', 'segundo_nombre', 'primer_apellido', 'segundo_apellido']
        for campo in campos_nombres:
            if campo in df.columns:
                df[campo] = df[campo].apply(limpiar_nombre)
        
        # Limpiar documentos
        if 'numero_documento' in df.columns:
            df['numero_documento'] = df['numero_documento'].astype(str).str.strip()
        
        # Procesar edad
        if 'edad' in df.columns:
            df['edad'] = pd.to_numeric(df['edad'], errors='coerce')
        
        # 4. GEOLOCALIZACI√ìN Y C√ìDIGOS DIVIPOLA
        print("üìç Procesando geolocalizaci√≥n...")
        
        def asignar_codigo_municipio(nombre_municipio):
            """Asigna c√≥digo DIVIPOLA basado en nombre de municipio"""
            if pd.isna(nombre_municipio):
                return None
                
            # Mapeo espec√≠fico para municipios del Tolima
            mapeo_municipios = {
                "IBAGUE": "73001",
                "IBAGU√â": "73001", 
                "MARIQUITA": "73408",
                "ESPINAL": "73268",
                "HONDA": "73349",
                "FLANDES": "73275",
                "MELGAR": "73449",
                "LIBANO": "73411",
                "L√çBANO": "73411",
                "CHAPARRAL": "73168",
                "PURIFICACION": "73585",
                "PURIFICACI√ìN": "73585",
                "GUAMO": "73319",
                # A√±adir m√°s municipios seg√∫n sea necesario
            }
            
            nombre_norm = str(nombre_municipio).strip().upper()
            
            # Buscar coincidencia exacta
            codigo = mapeo_municipios.get(nombre_norm)
            
            # Si no encuentra, buscar coincidencia parcial
            if codigo is None:
                for municipio, cod in mapeo_municipios.items():
                    if nombre_norm in municipio or municipio in nombre_norm:
                        codigo = cod
                        break
            
            return codigo or "73999"  # C√≥digo gen√©rico si no encuentra
        
        # Aplicar c√≥digos de municipio
        if 'municipio_residencia' in df.columns:
            df['codigo_municipio_residencia'] = df['municipio_residencia'].apply(asignar_codigo_municipio)
        elif 'municipio' in df.columns:
            df['codigo_municipio_residencia'] = df['municipio'].apply(asignar_codigo_municipio)
            df['municipio_residencia'] = df['municipio']
        
        # 5. VALIDACIONES Y FILTROS
        print("üîç Aplicando validaciones...")
        
        registros_inicial = len(df)
        
        # Filtrar registros con fecha v√°lida
        if 'fecha_notificacion' in df.columns:
            df = df.dropna(subset=['fecha_notificacion'])
        
        # Filtrar fechas coherentes
        fecha_minima = date(2020, 1, 1)
        fecha_maxima = date.today()
        
        if 'fecha_notificacion' in df.columns:
            df = df[
                (df['fecha_notificacion'] >= fecha_minima) &
                (df['fecha_notificacion'] <= fecha_maxima)
            ]
        
        # Filtrar edades v√°lidas
        if 'edad' in df.columns:
            df = df[
                (df['edad'].isna()) | 
                ((df['edad'] >= 0) & (df['edad'] <= 120))
            ]
        
        print(f"üìä Registros despu√©s de validaciones: {len(df):,}")
        print(f"üìä Registros filtrados: {registros_inicial - len(df):,}")
        
        # 6. CAMPOS CALCULADOS
        print("üîß Generando campos calculados...")
        
        # Calcular a√±o y semana epidemiol√≥gica si no existen
        if 'a√±o' not in df.columns and 'fecha_notificacion' in df.columns:
            df['a√±o'] = df['fecha_notificacion'].dt.year
        
        if 'semana_epidemiologica' not in df.columns and 'fecha_notificacion' in df.columns:
            df['semana_epidemiologica'] = df['fecha_notificacion'].dt.isocalendar().week
        
        # 7. SELECCIONAR COLUMNAS FINALES
        columnas_deseadas = [
            'codigo_evento', 'fecha_notificacion', 'semana_epidemiologica', 'a√±o',
            'codigo_prestador', 'codigo_subred', 'primer_nombre', 'segundo_nombre',
            'primer_apellido', 'segundo_apellido', 'tipo_documento', 'numero_documento',
            'edad', 'unidad_medida_edad', 'nacionalidad', 'codigo_municipio_residencia',
            'municipio_residencia'
        ]
        
        # Seleccionar solo columnas que existen
        columnas_finales = [col for col in columnas_deseadas if col in df.columns]
        df_final = df[columnas_finales].copy()
        
        # 8. ESTAD√çSTICAS PRE-CARGA
        print(f"\nüìä ESTAD√çSTICAS CASOS:")
        print(f"   Total casos: {len(df_final):,}")
        if 'municipio_residencia' in df_final.columns:
            print(f"   Municipios √∫nicos: {df_final['municipio_residencia'].nunique()}")
        if 'a√±o' in df_final.columns:
            a√±os = sorted(df_final['a√±o'].dropna().unique())
            print(f"   A√±os con casos: {a√±os}")
        
        return df_final
        
    except Exception as e:
        print(f"‚ùå Error procesando casos: {e}")
        import traceback
        traceback.print_exc()
        return None

def cargar_casos_postgresql(df_casos, tabla="casos_fiebre_amarilla"):
    """
    Carga casos a PostgreSQL
    """
    if df_casos is None or len(df_casos) == 0:
        print("‚ùå No hay datos de casos para cargar")
        return False
    
    print(f"\nüíæ Cargando {len(df_casos):,} casos a PostgreSQL...")
    
    try:
        engine = create_engine(DATABASE_URL)
        
        # Verificar conexi√≥n
        with engine.connect() as conn:
            conn.execute(text("SELECT 1"))
        
        # Cargar datos
        df_casos.to_sql(
            tabla,
            engine,
            if_exists='replace',  # Reemplazar casos completos
            index=False,
            chunksize=1000
        )
        
        # Verificar carga
        with engine.connect() as conn:
            total = conn.execute(text(f"SELECT COUNT(*) FROM {tabla}")).scalar()
            print(f"‚úÖ {total:,} casos cargados exitosamente")
            
            # Estad√≠sticas post-carga
            if total > 0:
                stats = pd.read_sql(text(f"""
                    SELECT 
                        COUNT(DISTINCT codigo_municipio_residencia) as municipios,
                        COUNT(DISTINCT a√±o) as a√±os,
                        MIN(fecha_notificacion) as fecha_min,
                        MAX(fecha_notificacion) as fecha_max
                    FROM {tabla}
                    WHERE fecha_notificacion IS NOT NULL
                """), conn)
                
                if len(stats) > 0:
                    s = stats.iloc[0]
                    print(f"üìä Municipios: {s['municipios']}")
                    print(f"üìä A√±os: {s['a√±os']}")  
                    print(f"üìÖ Per√≠odo: {s['fecha_min']} a {s['fecha_max']}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Error cargando a PostgreSQL: {e}")
        return False

def procesar_casos_completo(archivo_excel):
    """
    Proceso completo: Excel ‚Üí Limpieza ‚Üí PostgreSQL
    """
    print("ü¶† PROCESAMIENTO COMPLETO CASOS FIEBRE AMARILLA")
    print("=" * 60)
    
    inicio = datetime.now()
    
    try:
        # 1. Verificar archivo
        if not os.path.exists(archivo_excel):
            print(f"‚ùå Archivo no encontrado: {archivo_excel}")
            return False
        
        # 2. Procesar casos
        df_casos = procesar_casos_fiebre_amarilla(archivo_excel)
        
        if df_casos is None:
            print("‚ùå Error en procesamiento de casos")
            return False
        
        # 3. Cargar a PostgreSQL
        exito = cargar_casos_postgresql(df_casos)
        
        # 4. Resumen final
        duracion = datetime.now() - inicio
        print(f"\n{'='*60}")
        print("PROCESAMIENTO CASOS COMPLETADO")
        print("=" * 60)
        
        if exito:
            print("üéâ ¬°Casos cargados exitosamente!")
            print(f"üìä {len(df_casos):,} casos procesados")
        else:
            print("‚ö†Ô∏è Procesamiento con errores")
        
        print(f"‚è±Ô∏è Tiempo total: {duracion.total_seconds():.1f} segundos")
        
        return exito
        
    except Exception as e:
        print(f"‚ùå Error cr√≠tico: {e}")
        return False

# ================================
# EJECUCI√ìN PRINCIPAL
# ================================
if __name__ == "__main__":
    print("ü¶† PROCESADOR CASOS FIEBRE AMARILLA")
    print("=" * 45)
    
    archivo_default = "data/casos.xlsx"
    
    if not os.path.exists(archivo_default):
        print(f"‚ùå ERROR: No se encuentra '{archivo_default}'")
        print("\nüí° Opciones:")
        print("1. Colocar archivo en 'data/casos.xlsx'")
        print("2. Modificar variable archivo_default")
        print("3. Llamar: procesar_casos_completo('ruta/archivo.xlsx')")
    else:
        exito = procesar_casos_completo(archivo_default)
        
        if exito:
            print("\nüéØ PR√ìXIMOS PASOS:")
            print("1. Revisar datos en DBeaver: tabla 'casos_fiebre_amarilla'")
            print("2. Ejecutar vista v_casos_dashboard")
            print("3. Integrar con dashboard de vigilancia epidemiol√≥gica")
            print("4. ¬°An√°lisis de casos completo! üöÄ")